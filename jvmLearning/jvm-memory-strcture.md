[TOC]

# 前言

回答下面这些问题：

堆、栈、方法区、直接内存、堆和栈区别

# 1. VM内存区域模型

我找到了两种图，但是表示的是一个意思：

![](https://ws2.sinaimg.cn/large/006tNc79ly1fz1kszvboqj30dx0a3gmg.jpg)



![image-20190110163812865](https://ws4.sinaimg.cn/large/006tNc79ly1fz1ktm3gj5j30d70b2wg0.jpg)

------



## 1.1 程序计数器

线程私有。Program Counter Register。

是最小的一块内存区域，它的作用是当前线程所执行的字节码的行号指示器，在虚拟机的模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、异常处理、线程恢复等基础功能都需要依赖计数器完成。

## 1.2 虚拟机栈

线程私有。

描述的是java 方法执行的内存模型：每个方法被执行的时候 都会创建一个“栈帧”用于存储局部变量表(包括参数)、操作数栈、方法出口等信息。每个方法被调用到执行完的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。声明周期与线程相同，是线程私有的。

局部变量表存放了编译器可知的各种基本数据类型(`boolean`、`byte`、`char`、`short`、`int`、`float`、`long`、`double`)、对象引用(引用指针，并非对象本身)，其中64位长度的long和double类型的数据会占用2个局部变量的空间，其余数据类型只占1个。

**局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量是完全确定的，在运行期间栈帧不会改变局部变量表的大小空间。**

栈帧由三部分组成：**局部变量区、操作数栈、帧数据区**。局部变量区和操作数栈的大小要视对应的方法而定，他们是按字长计算的。但调用一个方法时，它从类型信息中得到此方法局部变量区和操作数栈大小，并据此分配栈内存，然后压入Java栈。

### 1.2.1 局部变量区

局部变量区被组织为以一个字长为单位、从0开始计数的数组，类型为short、byte和char的值在存入数组前要被转换成int值，而long和double在数组中占据连续的两项，在访问局部变量中的long或double时，只需取出连续两项的第一项的索引值即可,如某个long值在局部变量区中占据的索引时3、4项，取值时，指令只需取索引为3的long值即可。

如下代码以及图所示：

```java
public static int runClassMethod(int i,long l,float f,double d,Object o,byte b) { 
   return 0;   
}

public int runInstanceMethod(char c,double d,short s,boolean b) { 
       return 0;   
}
```

![img](https://ws3.sinaimg.cn/large/006tNc79ly1fz1p0c22pvj30j90a60sy.jpg)

### 1.2.2 操作数栈

和局部变量区一样，操作数栈也被组织成一个以字长为单位的数组。但和前者不同的是，它不是通过索引来访问的，而是通过入栈和出栈来访问的。可把操作数栈理解为存储计算时，临时数据的存储区域。下面我们通过一段简短的程序片段外加一幅图片来了解下操作数栈的作用。

```java
	int a = 1;
	int b = 98;
	int c = a+b;	
```

![img](https://ws2.sinaimg.cn/large/006tNc79ly1fz1p4v0g1pj30gc07dmzd.jpg)

从图中可以得出：**操作数栈其实就是个临时数据存储区域，它是通过入栈和出栈来进行操作的**。

### 1.2.3 **帧数据区**   

除了局部变量区和操作数栈外，**java栈帧还需要一些数据来支持常量池解析、正常方法返回以及异常派发机制**。这些数据都保存在java栈帧的帧数据区中。

当JVM执行到需要常量池数据的指令时，它都会通过帧数据区中指向常量池的指针来访问它。

 除了处理常量池解析外，帧里的数据还要处理java方法的正常结束和异常终止。如果是通过return正常结束，则当前栈帧从Java栈中弹出，恢复发起调用的方法的栈。如果方法又返回值，JVM会把返回值压入到发起调用方法的操作数栈。

为了处理java方法中的异常情况，帧数据区还必须保存一个对此方法异常引用表的引用。当异常抛出时，JVM给catch块中的代码。如果没发现，方法立即终止，然后JVM用帧区数据的信息恢复发起调用的方法的帧。然后再发起调用方法的上下文重新抛出同样的异常。

### 1.2.4 **栈的整个结构**

在前面就描述过：栈是由栈帧组成，每当线程调用一个java方法时，JVM就会在该线程对应的栈中压入一个帧，而帧是由局部变量区、操作数栈和帧数据区组成。那在一个代码块中，栈到底是什么形式呢？

```java
public class Main{    
	public static void addAndPrint(){      
    	double result = addTwoTypes(1,88.88);    
        System.out.println(result);    
    }   
         
    public static double addTwoTypes(int i,double d){  
    	return i + d;  
    }
}
```

执行过程中的三个快照：



![img](https://iamjohnnyzhuang.github.io/public/upload/5.png)





 上面所给的图，只想说明两件事情：

1. 只有在调用一个方法时，才为当前栈分配一个帧，然后将该帧压入栈
2. 帧中存储了对应方法的局部数据，方法执行完，对应的帧则从栈中弹出，并把返回结果存储在**调用 方法的帧的操作数栈中**

## 1.3 本地方法栈

线程私有。

Native Method Stack。

与虚拟机栈基本类似，区别在于虚拟机栈为虚拟机执行的java方法服务，而本地方法栈则是为Native方法服务。

## 1.4 **方法区** 

线程共享。

Method Area

也称”永久代” 、“非堆”， 它用于存储虚拟机加载的**类信息、常量、静态变量**、是各个线程共享的内存区域。默认最小值为16MB，最大值为64MB，可以通过`-XX:PermSize` 和 `-XX:MaxPermSize` 参数限制方法区的大小。

运行时常量池：是方法区的一部分，其中的主要内容来自于JVM对Class的加载。

Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种符号引用，这部分内容将在类加载后放到方法区的运行时常量池中。

**static数组和static实例都存放在堆内存中**。

![](https://ws4.sinaimg.cn/large/006tNc79ly1fzj50wonbrj30ol12j7bc.jpg)

## 1.5 堆

线程共享

Java Heap

也叫做java 堆、GC堆是java虚拟机所管理的内存中最大的一块内存区域，也是被各个线程共享的内存区域，在**JVM启动时创建**。该内存区域存放了**对象实例及数组**(所有new的对象)。

其大小通过`-Xms`(最小值)和`-Xmx`(最大值)参数设置，-Xms为JVM启动时申请的最小内存，默认为操作系统物理内存的1/64但小于1G，`-Xmx`为JVM可申请的最大内存，默认为物理内存的1/4但小于1G，默认当空余堆内存小于40%时，JVM会增大Heap到`-Xmx`指定的大小，可通过`-XX:MinHeapFreeRation=`来指定这个比列；当空余堆内存大于70%时，JVM会减小heap的大小到-Xms指定的大小，可通过`XX:MaxHeapFreeRation=`来指定这个比列，<u>对于运行系统，为避免在运行时频繁调整Heap的大小，通常-Xms与-Xmx的值设成一样</u>。

由于现在收集器都是采用分代收集算法，堆被划分为新生代和老年代。新生代主要存储新创建的对象和尚未进入老年代的对象。老年代存储经过多次新生代GC(Minor GC)任然存活的对象。

> 新生代： 程序新创建的对象都是从新生代分配内存，新生代由`Eden Space`和两块相同大小的`Survivor Space`(通常又称S0和S1或From和To)构成，可通过-Xmn参数来指定新生代的大小，也可以通过`-XX:SurvivorRation`来调整`Eden Space`及`Survivor Space`的大小。 老年代： 用于存放经过多次新生代GC任然存活的对象，例如缓存对象，新建的对象也有可能直接进入老年代，主要有两种情况：①.大对象，可通过启动参数设置`-XX:PretenureSizeThreshold=1024`(单位为字节，默认为0)来代表超过多大时就不在新生代分配，而是直接在老年代分配。②.大的数组对象，且数组中无引用外部对象。 老年代所占的内存大小为-Xmx对应的值减去-Xmn对应的值。

![img](https://ws3.sinaimg.cn/large/006tNc79ly1fz1nnzsivuj30en089gm0.jpg)

```java
Young Generation        即图中的Eden + From Space + To Space
Eden                    存放新生的对象
Survivor Space          有两个，存放每次垃圾回收后存活的对象
Old Generation          Tenured Generation 即图中的Old Space 
                        主要存放应用程序中生命周期长的存活对象
```

[关于新生代和老年代](https://app.yinxiang.com/shard/s61/nl/21811079/aa0dce69-6e7d-4bf6-807c-bb99889d3e3a/)

## 1.6 `堆(Heap)`和`非堆(Non-heap)`内存的区别

按照官方的说法：“Java 虚拟机具有一个堆，堆是运行时数据区域，所有类实例和数组的内存均从此处分配。堆是在 Java 虚拟机启动时创建的。”“在JVM中堆之外的内存称为非堆内存(Non-heap memory)”。可以看出**JVM主要管理两种类型的内存：堆和非堆**。

简单来说堆就是Java代码可及的内存，是留给开发人员使用的；非堆就是JVM留给 自己用的，所以方法区、JVM内部处理或优化所需的内存(如JIT编译后的代码缓存)、每个类结构(如运行时常数池、字段和方法数据)以及方法和构造方法 的代码都在非堆内存中。

## 1.7 直接内存

直接内存并不是虚拟机内存的一部分，也不是Java虚拟机规范中定义的内存区域。jdk1.4中新加入的NIO，引入了通道与缓冲区的IO方式，它可以调用Native方法直接分配堆外内存，这个堆外内存就是本机内存，不会影响到堆内存的大小。

------



# 2. Java堆内存的10个要点

1. Java堆内存是操作系统分配给JVM的内存的一部分。
2. 当我们创建对象时，它们存储在Java堆内存中。
3. 为了便于垃圾回收，Java堆空间分成三个区域，分别叫作New Generation, Old Generation或叫作Tenured Generation。
4. 你可以通过用JVM的命令行选项 -Xms, -Xmx, -Xmn来调整Java堆空间的大小。不要忘了在大小后面加上”M”或者”G”来表示单位。举个例子，你可以用 -Xmx256m来设置堆内存最大的大小为256MB。
5. 你可以用JConsole或者 Runtime.maxMemory(), Runtime.totalMemory(), Runtime.freeMemory()来查看Java中堆内存的大小。
6. 你可以使用命令“jmap”来获得heap dump，用“jhat”来分析heap dump。
7. Java堆空间不同于栈空间，栈空间是用来储存调用栈和局部变量的。
8. Java垃圾回收器是用来将死掉的对象(不再使用的对象)所占用的内存回收回来，再释放到Java堆空间中。
9. 当你遇到java.lang.outOfMemoryError时，不要紧张，有时候仅仅增加堆空间就可以了，但如果经常出现的话，就要看看Java程序中是不是存在内存泄露了。
10. 请使用Profiler和Heap dump分析工具来查看Java堆空间，可以查看给每个对象分配了多少内存。

# 3. 堆和栈的区别

- 功能不同

  - 栈内存用来存储局部变量和方法调用。

- 而堆内存用来存储Java中的对象。无论是**成员变量，局部变量，还是类变量（static的数组和实例）**，它们指向的对象都存储在堆内存中。

- 共享性不同

  - 栈内存是线程私有的。
  - 堆内存是所有线程共有的。

- 异常错误不同

  如果栈内存或者堆内存不足都会抛出异常。

  - 栈空间不足：java.lang.StackOverFlowError。
  - 堆空间不足：java.lang.OutOfMemoryError。

- 空间大小

  栈的空间大小远远小于堆的。



其他

[从0到1起步-跟我进入堆外内存的奇妙世界](https://www.jianshu.com/p/50be08b54bee)























