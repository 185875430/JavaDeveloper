<!--ts-->
   * [1. static代表着什么](#1-static代表着什么)
   * [2.  怎么使用static](#2--怎么使用static)
   * [3. Static的局限](#3-static的局限)
   * [4. 代码块](#4-代码块)
      * [4.1 普通代码块](#41-普通代码块)
      * [4.2  静态代码块](#42--静态代码块)
      * [4.3 同步代码块](#43-同步代码块)
      * [4.4  构造代码块](#44--构造代码块)
      * [4.5 静态代码块、构造代码块、构造函数执行顺序](#45-静态代码块构造代码块构造函数执行顺序)

<!-- Added by: anapodoton, at: Sat Feb 15 21:36:32 CST 2020 -->

<!--te-->

# 1. static代表着什么

在Java中并不存在全局变量的概念，但是我们可以通过static来实现一个“伪全局”的概念，在Java中static表示“全局”或者“静态”的意思，用来修饰**成员变量和成员方法，当然也可以修饰代码块**。

Java把内存分为栈内存和堆内存，其中栈内存用来存放一些基本类型的变量、数组和对象的引用，堆内存主要存放一些对象。在JVM加载一个类的时候，若该类存在static修饰的成员变量和成员方法，则会为这些成员变量和成员方法在固定的位置开辟一个固定大小的内存区域，有了这些“固定”的特性，那么JVM就可以非常方便地访问他们。同时如果静态的成员变量和成员方法不出作用域的话，它们的句柄都会保持不变。同时static所蕴含“静态”的概念表示着它是不可恢复的，即在那个地方，你修改了，他是不会变回原样的，你清理了，他就不会回来了。

同时被static修饰的成员变量和成员方法是独立于该类的，它不依赖于某个特定的实例变量，也就是说它被该类的所有实例共享。所有实例的引用都指向同一个地方，任何一个实例对其的修改都会导致其他实例的变化。

```java
public class User {
    private static int userNumber  = 0 ;

    public User(){
        userNumber ++;
    }

    public static void main(String[] args) {
        User user1 = new User();
        User user2 = new User();

        System.out.println("user1 userNumber：" + User.userNumber);
        System.out.println("user2 userNumber：" + User.userNumber);
    }
}    
------------
Output:
user1 userNumber：2
user2 userNumber：2
```

# 2.  怎么使用static

static可以用于修饰成员变量和成员方法，我们将其称之为静态变量和静态方法，直接通过类名来进行访问。

ClassName.propertyName

ClassName.methodName(……)

Static修饰的代码块表示静态代码块，当JVM装载类的时候，就会执行这块代码，其用处非常大。（对于代码块的使用这几天介绍，敬请关注）

**2.1、static变量**

static修饰的变量我们称之为静态变量，没有用static修饰的变量称之为实例变量，他们两者的区别是：

静态变量是随着类加载时被完成初始化的，它在内存中仅有一个，且JVM也只会为它分配一次内存，同时类所有的实例都共享静态变量，可以直接通过类名来访问它。

但是实例变量则不同，它是伴随着实例的，每创建一个实例就会产生一个实例变量，它与该实例同生共死。

所以我们一般在这两种情况下使用静态变量：对象之间共享数据、访问方便。

**2.2、static方法**

static修饰的方法我们称之为静态方法，我们通过类名对其进行直接调用。由于他在类加载的时候就存在了，它不依赖于任何实例，所以static方法必须实现，也就是说他不能是抽象方法abstract。

Static方法是类中的一种特殊方法，我们只有在真正需要他们的时候才会将方法声明为static。如Math类的所有方法都是静态static的。

**2.3、static代码块**

被static修饰的代码块，我们称之为静态代码块，静态代码块会随着类的加载一块执行，而且他可以随意放，可以存在于该了的任何地方。

# 3. Static的局限

Static确实是存在诸多的作用，但是它也存在一些缺陷。

- 1、它只能调用static变量。
- 2、它只能调用static方法。
- 3、不能以任何形式引用this、super。
- 4、static变量在定义时必须要进行初始化，且初始化时间要早于非静态变量。

总结：无论是变量，方法，还是代码块，只要用static修饰，就是在类被加载时就已经”准备好了”,也就是可以被使用或者已经被执行，都可以脱离对象而执行。反之，如果没有static，则必须要依赖于对象实例。

# 4. 代码块

在编程过程中我们可能会遇到如下这种形式的程序：

```java
public class Test {
   {
       ////
   }
}
```

这种形式的程序段我们将其称之为代码块，所谓代码块就是用大括号({})将多行代码封装在一起，形成一个独立的数据体，用于实现特定的算法。一般来说代码块是不能单独运行的，它必须要有运行主体。在Java中代码块主要分为四种：

## 4.1 普通代码块

普通代码块是我们用得最多的也是最普遍的，它就是在方法名后面用{}括起来的代码段。普通代码块是不能够单独存在的，它必须要紧跟在方法名后面。同时也必须要使用方法名调用它。

```java
public class Test {
   public void test(){
       System.out.println("普通代码块");
   }
}
```

## 4.2  静态代码块

想到静态我们就会想到static，静态代码块就是用static修饰的用{}括起来的代码段，它的主要目的就是对静态属性进行初始化。

```java
public class Test {
   static{
       System.out.println("静态代码块");
   }
}
```

## 4.3 同步代码块

使用 synchronized 关键字修饰，并使用“{}”括起来的代码片段，它表示同一时间只能有一个线程进入到该方法块中，是一种多线程保护机制。

## 4.4  构造代码块

在类中直接定义没有任何修饰符、前缀、后缀的代码块即为构造代码块。我们明白一个类必须至少有一个构造函数，构造函数在生成对象时被调用。构造代码块和构造函数一样同样是在生成一个对象时被调用，那么构造代码在什么时候被调用？如何调用的呢？看如下代码：

```java
public class Test {
   /**
    * 构造代码
    */
   {
       System.out.println("执行构造代码块...");
   }

   /**
    * 无参构造函数
    */
   public Test(){
       System.out.println("执行无参构造函数...");
   }

   /**
    * 有参构造函数
    * @param id  id
    */
   public Test(String id){
       System.out.println("执行有参构造函数...");
   }
}
```

上面定义了一个非常简单的类，该类包含无参构造函数、有参构造函数以及构造代码块，同时在上面也提过代码块是没有独立运行的能力，他必须要有一个可以承载的载体，那么编译器会如何来处理构造代码块呢？编译器会将代码块按照他们的顺序(假如有多个代码块)插入到所有的构造函数的最前端，这样就能保证不管调用哪个构造函数都会执行所有的构造代码块。上面代码等同于如下形式：

```java
public class Test {
   /**
    * 无参构造函数
    */
   public Test(){
       System.out.println("执行构造代码块...");
       System.out.println("执行无参构造函数...");
   }

   /**
    * 有参构造函数
    * @param id  id
    */
   public Test(String id){
       System.out.println("执行构造代码块...");
       System.out.println("执行有参构造函数...");
   }

}
```

运行结果

```java
public static void main(String[] args) {
       new Test();
       System.out.println("----------------");
       new Test("1");
   }
------------
Output:
执行构造代码块...
执行无参构造函数...
----------------
执行构造代码块...
执行有参构造函数...
```

从上面的运行结果可以看出在new一个对象的时候总是先执行构造代码，再执行构造函数，但是有一点需要注意构造代码不是在构造函数之前运行的，它是依托构造函数执行的。正是由于构造代码块有这几个特性，所以它常用于如下场景：

**1、 初始化实例变量**

如果一个类中存在若干个构造函数，这些构造函数都需要对实例变量进行初始化，如果我们直接在构造函数中实例化，必定会产生很多重复代码，繁琐和可读性差。这里我们可以充分利用构造代码块来实现。这是利用编译器会将构造代码块添加到每个构造函数中的特性。

**2、 初始化实例环境**

一个对象必须在适当的场景下才能存在，如果没有适当的场景，则就需要在创建对象时创建此场景。我们可以利用构造代码块来创建此场景，尤其是该场景的创建过程较为复杂。构造代码会在构造函数之前执行。

上面两个常用场景都充分利用构造代码块的特性，能够很好的解决在实例化对象时构造函数比较难解决的问题，利用构造代码不仅可以减少代码量，同时也是程序的可读性增强了。特别是当一个对象的创建过程比较复杂，需要实现一些复杂逻辑，这个时候如果在构造函数中实现逻辑，这是不推荐的，因为我们提倡构造函数要尽可能的简单易懂，所以我们可以使用构造代码封装这些逻辑实现部分。

## 4.5 静态代码块、构造代码块、构造函数执行顺序

从词面上我们就可以看出他们的区别。静态代码块，静态，其作用级别为类，构造代码块、构造函数，构造，其作用级别为对象。

- 1、 静态代码块，它是随着类的加载而被执行，只要类被加载了就会执行，而且只会加载一次，主要用于给类进行初始化。
- 2、 构造代码块，每创建一个对象时就会执行一次，且优先于构造函数，主要用于初始化不同对象共性的初始化内容和初始化实例环境。
- 3、 构造函数，每创建一个对象时就会执行一次。同时构造函数是给特定对象进行初始化，而构造代码是给所有对象进行初始化，作用区域不同。

通过上面的分析，他们三者的执行顺序应该为：静态代码块 > 构造代码块 > 构造函数。

```java
public class Test {
   /**
    * 静态代码块
    */
   static{
       System.out.println("执行静态代码块...");
   }

   /**
    * 构造代码块
    */
   {
       System.out.println("执行构造代码块...");
   }

   /**
    * 无参构造函数
    */
   public Test(){
       System.out.println("执行无参构造函数...");
   }

   /**
    * 有参构造函数
    * @param id
    */
   public Test(String id){
       System.out.println("执行有参构造函数...");
   }

   public static void main(String[] args) {
       System.out.println("----------------------");
       new Test();
       System.out.println("----------------------");
       new Test("1");
   }
}
-----------
Output:
执行静态代码块...
----------------------
执行构造代码块...
执行无参构造函数...
----------------------
执行构造代码块...
执行有参构造函数...
```
